# 最佳化指南

Gemini Telegram Bot 的效能最佳化、最佳實踐和未來改進建議。

## 已實施的最佳化

### 1. 程式碼架構

#### 模組化設計
**狀態：** ✅ 已實施

- 程式碼組織成邏輯模組（bot/、gemini/、tools/、permissions/）
- 高內聚力、低耦合
- 易於測試和維護
- 每個檔案都有單一、清晰的責任

**優點：**
- 加快開發和偵錯速度
- 更容易新增新功能
- 更好的程式碼可重用性

#### 不可變模式
**狀態：** ✅ 已實施

- 所有資料結構使用不可變模式
- 無直接物件變動
- 函數返回新物件而不是修改現有物件

**範例：**
```typescript
// 工作階段更新建立新物件
return {
  ...session,
  workingDirectory: newPath
}
```

**優點：**
- 防止意外副作用
- 更容易理解狀態變更
- 更好的偵錯和測試

### 2. 效能最佳化

#### 延遲載入
**狀態：** ✅ 已實施

- Playwright 瀏覽器僅在需要時載入
- MCP 連接按需建立
- 工具動態註冊

**優點：**
- 更快的機器人啟動時間
- 未使用功能時的較低記憶體使用
- 更好的資源利用

#### 資源清理
**狀態：** ✅ 已實施

- 每次操作後關閉瀏覽器內容
- 臨時檔案被清理
- MCP 客戶端連接池

**程式碼範例：**
```typescript
const context = await browser.newContext()
try {
  // 使用 context
} finally {
  await context.close() // 始終清理
}
```

**優點：**
- 無記憶體洩漏
- 隨著時間保持一致效能
- 更好的資源管理

#### 配額管理
**狀態：** ✅ 已實施

- 追蹤每個請求的令牌使用
- 執行請求限制（每小時/每天）
- 在 80% 閾值時警告

**優點：**
- 防止 API 成本超支
- 跨使用者的公平使用
- 可預測的營運成本

### 3. 安全性最佳化

#### 路徑驗證
**狀態：** ✅ 已實施

- 存取前驗證所有檔案路徑
- 路徑遍歷預防
- 敏感路徑被阻止（.ssh、.env 等）
- 允許路徑白名單

**優點：**
- 防止未授權的檔案存取
- 保護敏感資料
- 減少安全漏洞

#### 輸入驗證
**狀態：** ✅ 已實施

- 所有使用者輸入使用 Zod 模式驗證
- 在執行階段執行類型安全
- 早期拒絕無效輸入

**程式碼範例：**
```typescript
const FileOperationParamsSchema = z.object({
  path: z.string().min(1),
  content: z.string().optional()
})
```

**優點：**
- 防止注入攻擊
- 更好的錯誤訊息
- 類型安全保證

#### 權限系統
**狀態：** ✅ 已實施

- 兩層權限系統（自動批准 vs 需要確認）
- 讀取操作自動批准
- 寫入/破壞性操作需要確認
- 確認的 30 秒逾時

**優點：**
- 防止意外資料遺失
- 使用者對破壞性操作的控制
- 清晰的安全邊界

### 4. 錯誤處理

#### 全面的 Try-Catch
**狀態：** ✅ 已實施

- 所有非同步操作被 try-catch 包裝
- 使用內容記錄錯誤
- 對使用者友善的錯誤訊息

**優點：**
- 機器人在錯誤時保持穩定
- 更好的日誌偵錯
- 清晰的使用者回饋

#### 優雅降級
**狀態：** ✅ 已實施

- MCP 伺服器故障不會使機器人崩潰
- 瀏覽器自動化錯誤優雅處理
- 偵測並報告遺失的相依套件

**優點：**
- 高可用性
- 更好的使用者體驗
- 部分功能維持

### 5. 程式碼品質

#### TypeScript 嚴格模式
**狀態：** ✅ 已實施

- 啟用嚴格類型檢查
- 無隱含任何類型
- 強制執行空安全

**優點：**
- 在編譯時捕捉錯誤
- 更好的 IDE 支援
- 自我說明的程式碼

#### 小函式
**狀態：** ✅ 已實施

- 函式保持在 50 行以下
- 單一責任原則
- 清晰的函式名稱

**優點：**
- 更容易測試
- 更好的可讀性
- 更簡單的維護

#### 無魔法數字
**狀態：** ✅ 已實施

- 常數在配置中定義
- 環境變數用於配置
- 所有值的清晰命名

**範例：**
```typescript
const DEFAULT_TIMEOUT = 30000 // 30 秒
const QUOTA_WARNING_THRESHOLD = 0.8 // 80%
```

**優點：**
- 易於調整行為
- 自我說明的程式碼
- 集中式配置

## 效能指標

### 目前效能（估計）

| 操作 | 平均時間 | 備註 |
|-----------|--------------|-------|
| 機器人啟動 | 2-3 秒 | 包括相依套件載入 |
| 簡單訊息 | 1-2 秒 | 直接 Gemini 回應 |
| 檔案讀取 | 0.5-1 秒 | 本地檔案系統存取 |
| 檔案寫入 | 0.5-1 秒 | 包括權限提示 |
| 瀏覽器瀏覽 | 3-5 秒 | 取決於網站 |
| 螢幕截圖 | 4-6 秒 | 包括頁面載入 + 呈現 |
| 圖片生成 | 10-15 秒 | 取決於 Imagen API |
| 文件分析 | 2-4 秒 | 取決於檔案大小 |

### 記憶體使用

- 基本記憶體：~50-80 MB
- 帶瀏覽器：+100-150 MB（每個內容）
- 峰值記憶體：~200-300 MB（帶活躍瀏覽器）

### API 配額使用

- 平均訊息：~1000-2000 個令牌
- 函式呼叫：+500-1000 個令牌開銷
- 圖片生成：單獨配額（非基於令牌）

## 未來的最佳化機會

### 1. 快取

#### 瀏覽器頁面快取
**優先級：** 中等
**工作量：** 低

**實施：**
```typescript
const pageCache = new Map<string, { page: Page, timestamp: number }>()

async function getCachedPage(url: string): Promise<Page> {
  const cached = pageCache.get(url)
  if (cached && Date.now() - cached.timestamp < 5 * 60 * 1000) {
    return cached.page // 在 5 分鐘內重用
  }
  // 否則建立新頁面
}
```

**優點：**
- 更快的重複瀏覽
- 減少 API 呼叫
- 更好的回應時間

**注意事項：**
- 快取失效策略
- 記憶體限制
- 過期資料處理

#### Gemini 回應快取
**優先級：** 低
**工作量：** 中等

**實施：**
- 快取相同查詢
- 基於時間的失效（1 小時）
- 使用者特定的快取鍵

**優點：**
- 重複問題的更快回應
- 減少 API 成本
- 較低的配額使用

**注意事項：**
- 隱私考慮（使用者資料）
- 快取大小限制
- 新鮮度要求

### 2. 並行處理

#### 批量檔案操作
**優先級：** 高
**工作量：** 中等

**實施：**
```typescript
// 並行處理多個檔案
const results = await Promise.all(
  files.map(file => processFile(file))
)
```

**優點：**
- 更快的批量操作
- 更好的 CPU 利用
- 改進的使用者體驗

**使用案例：**
- 檔案組織
- 批量文件分析
- 多個螢幕截圖捕捉

#### 並行工具執行
**優先級：** 中等
**工作量：** 高

**實施：**
- 允許多個工具同時執行
- 資源密集型操作的佇列系統
- 獨立任務的並行執行

**優點：**
- 更快的複雜查詢
- 更好的輸送量
- 改進的回應性

**注意事項：**
- 資源限制（瀏覽器實例）
- 競爭條件
- 錯誤處理複雜性

### 3. 資源管理

#### 瀏覽器實例池
**優先級：** 高
**工作量：** 中等

**目前：** 每個請求的新瀏覽器內容
**建議：** 跨請求重用瀏覽器實例

**實施：**
```typescript
class BrowserPool {
  private browsers: Browser[] = []
  private maxBrowsers = 3

  async getContext(): Promise<BrowserContext> {
    // 重用現有瀏覽器或建立新的
    // 將總瀏覽器限制為 maxBrowsers
  }
}
```

**優點：**
- 更快的瀏覽器操作
- 較低的記憶體開銷
- 更好的資源利用

**注意事項：**
- 內容隔離（安全性）
- 清理策略
- 最大池大小

#### 流式傳輸回應
**優先級：** 低
**工作量：** 高

**目前：** 等待完整 Gemini 回應
**建議：** 將部分回應流式傳輸給使用者

**優點：**
- 更快的感知回應時間
- 長回應的更好使用者體驗
- 可顯示進度

**注意事項：**
- Telegram API 限制
- 複雜的實施
- 中途流式傳輸的錯誤處理

### 4. 資料庫整合

#### 工作階段持續性
**優先級：** 中等
**工作量：** 中等

**目前：** 記憶體中的工作階段儲存
**建議：** 資料庫支援的工作階段（SQLite/Redis）

**優點：**
- 機器人重啟後工作階段存活
- 更好的多實例支援
- 歷史資料分析

**實施：**
```typescript
interface SessionStore {
  get(userId: number): Promise<UserSession | null>
  set(userId: number, session: UserSession): Promise<void>
  delete(userId: number): Promise<void>
}
```

**注意事項：**
- 資料庫選擇（簡單用 SQLite，分散式用 Redis）
- 遷移策略
- 備份和復原

#### 對話歷史
**優先級：** 低
**工作量：** 高

**目前：** 有限的記憶體中歷史
**建議：** 資料庫中的完整對話歷史

**優點：**
- 長期內容
- 分析和見解
- 使用者對話搜尋

**注意事項：**
- 儲存成本
- 隱私（資料保留政策）
- 查詢效能

### 5. 監控與可觀測性

#### 結構化日誌
**優先級：** 高
**工作量：** 低

**目前：** Winston 日誌至檔案
**建議：** 使用日誌級別的結構化 JSON 日誌

**實施：**
```typescript
logger.info('Tool executed', {
  userId: session.userId,
  toolName: tool.name,
  duration: Date.now() - startTime,
  success: true
})
```

**優點：**
- 更好的日誌分析
- 更容易偵錯
- 效能監控

**工具：**
- Winston（已使用，增強格式）
- 日誌聚合（未來：ELK stack、Datadog）

#### 指標收集
**優先級：** 中等
**工作量：** 中等

**要追蹤的指標：**
- 請求延遲（p50、p95、p99）
- 按工具的錯誤率
- 配額使用隨時間
- 工具使用頻率
- 使用者活動模式

**實施：**
- 記憶體中的指標收集器
- 定期匯出到監控服務
- 視覺化的儀表板

**優點：**
- 效能見解
- 使用模式
- 主動式問題偵測

#### 健康檢查
**優先級：** 高
**工作量：** 低

**實施：**
```typescript
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    checks: {
      gemini: await checkGeminiConnection(),
      browser: await checkBrowserAvailable(),
      mcp: await checkMCPServers()
    }
  })
})
```

**優點：**
- 監控機器人健康
- 自動警報
- 與監控工具整合

### 6. 測試改進

#### 單位測試涵蓋
**優先級：** 高
**工作量：** 高

**目前：** 最少測試
**目標：** 80%+ 涵蓋

**重點領域：**
- 工具執行邏輯
- 權限驗證
- 路徑安全
- 配額計算

**優點：**
- 及早捕捉回歸
- 更安全的重構
- 更好的程式碼品質

#### 整合測試
**優先級：** 中等
**工作量：** 高

**要新增的測試：**
- 端到端命令流
- 使用真實 API（模擬）的工具執行
- 權限系統工作流
- 錯誤情境

**優點：**
- 部署的信心
- 自動化 QA
- 防止生產問題

#### 效能測試
**優先級：** 低
**工作量：** 中等

**測試：**
- 負載測試（並行使用者）
- 壓力測試（配額限制）
- 記憶體洩漏偵測
- 回應時間基準

**優點：**
- 防止效能回歸
- 容量規劃
- 最佳化驗證

### 7. 可擴展性

#### 多實例支援
**優先級：** 低
**工作量：** 高

**目前：** 單一機器人實例
**建議：** 具有共用狀態的多個實例

**要求：**
- 共用工作階段儲存（Redis）
- 分散式配額追蹤
- 負載平衡

**優點：**
- 處理更多使用者
- 高可用性
- 更好的效能

**注意事項：**
- 複雜性增加
- 基礎設施成本
- 協調開銷

#### 速率限制
**優先級：** 中等
**工作量：** 低

**實施：**
```typescript
class RateLimiter {
  private requests: Map<number, number[]> = new Map()

  checkLimit(userId: number, maxPerMinute: number): boolean {
    const now = Date.now()
    const userRequests = this.requests.get(userId) || []
    const recentRequests = userRequests.filter(t => now - t < 60000)
    return recentRequests.length < maxPerMinute
  }
}
```

**優點：**
- 防止濫用
- 公平的資源分配
- API 保護

### 8. 使用者體驗

#### 命令自動完成
**優先級：** 低
**工作量：** 中等

**實施：**
- 使用 Telegram 註冊機器人命令
- 在聊天輸入中顯示命令清單
- 包括參數提示

**優點：**
- 更容易發現
- 減少使用者錯誤
- 更好的 UX

#### 進度指示器
**優先級：** 中等
**工作量：** 低

**實施：**
```typescript
await ctx.sendChatAction('typing') // 顯示輸入指示器
await ctx.sendChatAction('upload_photo') // 顯示上傳指示器
```

**優點：**
- 更好的感知效能
- 使用者知道機器人正在工作
- 減少重複請求

#### 內嵌鍵盤
**優先級：** 低
**工作量：** 中等

**使用案例：**
- 快速檔案操作（刪除/重新命名）
- 使用按鈕瀏覽目錄
- 工具選擇菜單

**優點：**
- 更快的互動
- 更好的行動體驗
- 減少輸入

## 最佳化檢查清單

在每次發行前：

- [ ] 執行 TypeScript 類型檢查（`bun run typecheck`）
- [ ] 檢查 console.log 語句
- [ ] 檢查錯誤處理涵蓋
- [ ] 在新鮮環境上測試
- [ ] 驗證所有環境變數已記錄
- [ ] 檢查硬編碼值
- [ ] 檢查安全配置
- [ ] 使用配額限制測試
- [ ] 驗證所有檔案路徑已驗證
- [ ] 檢查記憶體洩漏（長時間執行測試）
- [ ] 檢查日誌輸出（檢查敏感資料）
- [ ] 測試權限提示
- [ ] 驗證瀏覽器清理

## 效能調整

### 環境變數

調整這些以獲得最佳效能：

```bash
# 瀏覽器
BROWSER_HEADLESS=true          # 使用無頭模式（更快）
BROWSER_TIMEOUT=30000          # 30 秒（為慢速網站調整）

# 配額（根據使用模式調整）
MAX_REQUESTS_PER_HOUR=100      # 防止濫用
MAX_TOKENS_PER_DAY=1000000     # 控制成本

# 模型選擇
GEMINI_DEFAULT_MODEL=gemini-2.0-flash-exp  # 快速模型
# 考慮 gemini-pro 以獲得更好的品質（更慢）
```

### 系統資源

建議的系統規格：

- **最低：** 512MB RAM、1 CPU 核心
- **建議：** 2GB RAM、2 CPU 核心
- **磁碟：** 500MB 用於相依套件 + 日誌

對於生產環境：
- **生產：** 4GB RAM、4 CPU 核心
- **磁碟：** 2GB + 日誌輪轉

## 監控最佳實踐

### 日誌輪轉

```bash
# 新增到 crontab 以進行自動日誌輪轉
0 0 * * * find /path/to/logs -name "*.log" -mtime +7 -delete
```

### 要監控的指標

- 回應時間趨勢
- 按工具的錯誤率
- 隨時間的記憶體使用
- 配額消費模式
- 使用者活動分佈

### 警報

設定警報以進行以下情況：
- 機器人停機
- 錯誤率 > 5%
- 記憶體使用 > 80%
- 配額耗盡
- API 故障

## 結論

此機器人已針對以下項目進行最佳化：
- 安全性（路徑驗證、權限）
- 可維護性（模組化程式碼、TypeScript）
- 可靠性（錯誤處理、清理）
- 效能（延遲載入、資源管理）

未來的最佳化應側重於：
1. 測試涵蓋（最高優先級）
2. 監控和可觀測性
3. 瀏覽器實例池
4. 快取策略
5. 可擴展性（如果需要）

大多數最佳化應由以下因素驅動：
- 實際效能指標
- 使用者回饋
- 使用模式
- 成本分析

避免過早最佳化。先測量，後最佳化。
